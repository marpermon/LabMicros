#include <iostream>
#include <unistd.h>  // For usleep
#include <wiringPiI2C.h>  // For I2C communication
#include "tensorflow/lite/interpreter.h"
#include "tensorflow/lite/kernels/register.h"
#include "tensorflow/lite/model.h"
#include "model.h"  // Include the model header file generated by xxd

// Replace with your sensor's I2C address
const int SENSOR_I2C_ADDRESS = 0x40;

int main() {
    
    // Load TensorFlow Lite model
    const tflite::Model* model = tflite::GetModel(model_optimized_tflite);
    if (model->version() != TFLITE_SCHEMA_VERSION) {
        std::cerr << "Model schema version is not compatible!" << std::endl;
        return -1;
    }

    // Create an interpreter for the model
    tflite::ops::builtin::BuiltinOpResolver resolver;
    tflite::InterpreterBuilder builder(model, resolver);
    std::unique_ptr<tflite::Interpreter> interpreter;
    builder(&interpreter);

    if (!interpreter) {
        std::cerr << "Failed to create interpreter!" << std::endl;
        return -1;
    }

    // Allocate tensors
    if (interpreter->AllocateTensors() != kTfLiteOk) {
        std::cerr << "Failed to allocate tensors!" << std::endl;
        return -1;
    }

    // Get input and output tensor pointers
    float* input = interpreter->typed_input_tensor<float>(0);
    float* output = interpreter->typed_output_tensor<float>(0);

    // Continuous real-time reading and inference
    while (true) {
        // Read sensor data (example: 6 data points)
        for (int i = 0; i < 6; ++i) {
            input[i] = wiringPiI2CRead(sensor);  // Replace with actual sensor read logic
            usleep(1000);  // Simulate sensor read delay
        }

        // Perform inference
        if (interpreter->Invoke() != kTfLiteOk) {
            std::cerr << "Failed to invoke interpreter!" << std::endl;
            return -1;
        }

        // Process output
        std::cout << "Output: ";
        for (int i = 0; i < 6; ++i) {
            std::cout << output[i] << " ";
        }
        std::cout << std::endl;

        // Sleep or adjust the loop frequency as necessary
        usleep(500000);  // 500ms delay (adjust for your application)
    }

    return 0;
}
